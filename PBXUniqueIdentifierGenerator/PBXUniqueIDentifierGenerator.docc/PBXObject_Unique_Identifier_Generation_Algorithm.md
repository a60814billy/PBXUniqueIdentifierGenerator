

# Algorithm of Generating PBXObject Unique Identifier 

This document describes the algorithm used to generate the 96-bit (12-byte) unique identifiers (PBXObjectIDs) for Xcode project objects, as implemented in `PBXUniqueIdentifierGenerator`.

## Overview

The `PBXUniqueIdentifier` is a 96-bit value used to uniquely identify objects within a `project.pbxproj` file. It is designed to be unique across different users, processes, and time.

The identifier is constructed by packing specific fields into a 12-byte structure. The hexadecimal representation of this identifier (often seen in `.pbxproj` files) is a 24-character string.

## Data Structure

The identifier consists of the following 5 fields, packed in order:

| Field | Size | Description |
|-------|------|-------------|
| **User Hash** | 8 bits (1 byte) | A hash derived from the current OS user's name. |
| **PID** | 8 bits (1 byte) | The lower 8 bits of the current Process ID. |
| **Sequence** | 16 bits (2 bytes) | A rolling sequence number (stored in Big Endian). |
| **Timestamp** | 32 bits (4 bytes) | Seconds since the Reference Date (Jan 1 2001) (stored in Big Endian). |
| **Random** | 32 bits (4 bytes) | A random 24-bit integer (stored in 4 bytes) generated once per session. |

### Binary Layout

```
[ User Hash (1B) ] [ PID (1B) ] [ Sequence (2B) ] [ Timestamp (4B) ] [ Random (4B) ]
Total: 12 Bytes (96 bits)
```

## Generation Algorithm

### 1. Global State Initialization

When the generator is first accessed, a global state is initialized with values that persist for the lifetime of the process:

*   **User Hash**: A custom hashing algorithm iterates over the system user name (`NSUserName()`). It maps characters using a custom 5-bit packing table and combines them using bitwise shifts and XOR operations. The final result is truncated to 8 bits.
*   **PID**: The current process identifier is retrieved, and only the lower 8 bits are retained.
*   **Random Seed**: A random value masked to 24 bits (0xFFFFFF). This value remains constant for all IDs generated by this process instance.
*   **Initial Sequence**: The sequence counter is initialized with a random value.

### 2. Next Identifier Calculation

For each call to `nextIdentifier`, the algorithm performs the following steps in a thread-safe manner:

1.  **Increment Sequence**: The 16-bit `sequence` counter is incremented.
2.  **Update Timestamp**:
    *   The current time (seconds since reference date) is retrieved.
    *   If the current time is greater than the stored `time`, the stored `time` is updated, and the current sequence is recorded as the `firstSequenceForTheTime`.
    *   If the time hasn't changed (generating multiple IDs within the same second):
        *   The algorithm checks if the `sequence` has wrapped around and caught up to `firstSequenceForTheTime`.
        *   If a collision is detected (i.e., more than 65,536 IDs generated in one second), the stored `time` is artificially incremented to preserve uniqueness.

### 3. Final Assembly

The components are assembled into the `PBXUniqueIdentifier` structure:

*   `userHash` and `pid` are copied from the global state.
*   `sequence` is converted to **Big Endian**.
*   `time` is converted to **Big Endian**.
*   `random` is copied from the global state.

## Implementation Details

*   **Byte Order**: Note that the `sequence` and `time` fields are explicitly swapped to Big Endian format (`CFSwapInt16HostToBig`, `CFSwapInt32HostToBig`) before being stored.
*   **Uniqueness Guarantee**: Uniqueness is primarily achieved through the combination of:
    *   **Spatial separation**: User Hash (User), PID (Process), Random (Session).
    *   **Temporal separation**: Timestamp, Sequence.
